unit FileUpload.Controle;

interface

Uses System.SysUtils,
  System.Classes,
  StrUtils,
  Banco.Classe,
  Vcl.ExtCtrls,
  FormDataReader,
  IdBaseComponent,
  IdComponent,
  IdCustomHTTPServer,
  IdContext;

type
  TControleFileUpload = Class
  Public
    function Upload(DirUpload: String; ARequestInfo: TIdHTTPRequestInfo): String;
  End;

implementation

uses
  System.JSON;


function TControleFileUpload.Upload(DirUpload: String; ARequestInfo: TIdHTTPRequestInfo): Boolean;
var
  Decoder: TIdMultiPartFormDataStreamReader;
  lPathFile, FileName: String;
  lMemoryStream: TMemoryStream;
begin
    Result:=False;
    lPathFile := IncludeTrailingPathDelimiter(ExtractFilePath(ParamStr(0)));
    lPathFile := lPathFile + IncludeTrailingPathDelimiter(Trim(DirUpload));

    if (lPathFile <> EmptyStr) and (Not(DirectoryExists(lPathFile))) then
      ForceDirectories(lPathFile);

    Decoder := TIdMultiPartFormDataStreamReader.Create(ARequestInfo);

    Try
      FileName := Decoder.Fields.Items[0].FileName;
      if (Assigned(Decoder.Fields.Items[0].FieldStream)) and (FileName <> EmptyStr) then
      begin

        lMemoryStream := TMemoryStream.Create;
        lMemoryStream.LoadFromStream(Decoder.Fields.Items[0].FieldStream);

        if FileExists(Pchar(lPathFile + FileName)) then
          DeleteFile(Pchar(lPathFile + FileName));

        if FileExists(Pchar(lPathFile + FileName)) then
          raise Exception.Create('Não foi poisivél subistituir o ' + FileName + ' no servidor');

        lMemoryStream.SaveToFile(lPathFile + FileName);
        Result:=FileExists(lPathFile + FileName);

      end
      else
      begin
        raise Exception.Create('Erro na recepção do arquivo tente novamente');

      end;

    Finally

      if Assigned(lMemoryStream) then
        FreeAndNil(lMemoryStream);

      if Assigned(Decoder) then
      begin
        Decoder.Fields.Clear;
        Decoder.Clear;
       // FreeAndNil(Decoder);
      end;

    End;


end;

end.
